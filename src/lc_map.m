function LC_map(lat,lon,maxlat,minlat,maxlon,minlon)
    
    %LC_MAP plot a map using a Lambert Conformal projection
    %
    %    LC_MAP(lat,lon,maxlat,minlat,maxlon,minlon)
    %
    %    Function to plot a map using a Lambert Conformal projection
    %    with two standard parallels which are chosen to be 1/4 of the
    %    vertical span of the map from the top (phi1) and bottom (phi2).
    %    The standard meridian is chosen to be the center meridian of
    %    the map.
    %
    %    where * lat & lon: array of latitudes and longitudes of map feature
    %	   * maxlat & minlat: maximum and minimum latitude of map
    %	   * maxlon & minlon: maximum and minimum longitude of map
    %	                      (remember: South & West are negative!)
    %
    %	The line type and line width can be set using the following
    %	global variables: "line_type" & "line_width".
    %	If these global variables are not set, it will use the
    %	following defaults: line_type = '-' & line_width = [0.5]
    
    report_this_filefun();
    
    global scale
    global phi0 lambda0 phi1 phi2
    global maxlatg minlatg maxlong minlong
    global line_type line_width
    
    ZG = ZmapGlobal.Data;
    % grab globals
    torad = ZG.torad;
    
    
    maxlatg = maxlat; minlatg = minlat;
    maxlong = maxlon; minlong = minlon;
    
    % set some constants
    scale = 1;
    
    % get the Standard Parallels and Center Coordinates
    phi1 = (minlat + ((maxlat - minlat) / 4)) * torad;
    phi2 = (maxlat - ((maxlat - minlat) / 4)) * torad;
    phi0 = (phi1 + phi2) / 2;
    lambda0 = ((minlon + maxlon) / 2) * torad;
    
    % find index of all points which are valid for this map & that are
    % not seperator points (ie: NaN)
    index = find(minlat < lat & lat < maxlat & minlon < lon & lon < maxlon &...
        isfinite(lat) & isfinite(lon));
    
    % convert all valid points to cartesian coordinates
    if index > 0
        [x(index) y(index)] = lc_tocar(lat(index),lon(index));
    end
    
    % reinsert the segment seperator points (ie: NaN)
    idxzero = find(x == 0 & y == 0);
    
    if idxzero > 0
        x(idxzero) = ones(size(x(idxzero))) * NaN;
        y(idxzero) = ones(size(y(idxzero))) * NaN;
    end
    
    % keep in memory if HOLD was on or off to put it back the way it was
    % after the plot
    if ishold
        hold_flag = 1;
    else
        hold_flag = 0;
    end
    
    lc_borde('-k',2)
    hold on
    
    lc_grid(':',0.20)
    
    if isempty(line_type), line_type = '-k'; end
    if isempty(line_width), line_width = [0.5]; end
    plot(x,y,'-k','LineWidth',line_width)
    
    axis('equal')
    set(gca,'Visible','off')
    set(gcf,'PaperPosition',[1 .5 9 6.9545])
    
    % put HOLD back the way it was before this function was called
    if hold_flag
        hold on
    else
        hold off
    end
    
end


function lc_borde(line_type,line_thick)
    
    %LC_PLOT_BORDER
    %
    %	LC_plot_border(line_type,line_thick)
    %
    %	Function to plot a border on the map generated by LC_MAP
    %	LINE_TYPE is any of the line types used by the PLOT command.
    %	LINE_THICK is the width of the line in "points".
    %	   (1 point = 1/72 inch).
    %	If no values are given, it will use the defaults: '-' & 2.
    %
    %	NOTE: The LC_MAP function has to have been called first
    %	to set some required global variables.
    
    global maxlatg minlatg maxlong minlong
    
    if nargin < 2
        line_thick = 2;
        if nargin < 1
            line_type = '-';
        end
    end
    
    bdlon(1:100) = minlong:(maxlong-minlong)/99:maxlong;
    bdlon(101:200) = ones(1,100) * maxlong;
    bdlon(201:300) = maxlong:-(maxlong-minlong)/99:minlong;
    bdlon(301:400) = ones(1,100) * minlong;
    
    bdlat(1:100) = ones(1,100) * maxlatg;
    bdlat(101:200) = maxlatg:-(maxlatg-minlatg)/99:minlatg;
    bdlat(201:300) = ones(1,100) * minlatg;
    bdlat(301:400) = minlatg:(maxlatg-minlatg)/99:maxlatg;
    
    [xbd, ybd] = lc_tocart(bdlat,bdlon);
    
    plot(xbd,ybd,line_type,'LineWidth',line_thick)
    
end


function lc_grid(line_type,line_width)
    
    %LC_PLOT_GRID
    %
    %	LC_plot_grid(line_type,line_width)
    %
    %	Function to plot a grid on the map generated by LC_MAP
    %	This function sets the size of the grid automatically according
    %	to the scale of the map.
    %	LINE_TYPE is the grid line style as available for the PLOT command
    %	(ie: [ - | -- | : | -. ]). The default is [ - ].
    %	LINE_WIDTH is the line thickness to be used for the grid. It has
    %	to be a value > [0.01].
    %
    %	NOTE: The LC_MAP function has to have been called before
    %	you can use this function as it needs some global variables
    %	to be set.
    
    global maxlatg minlatg maxlong minlong
    
    if nargin < 2
        line_width = [0.01];
        if nargin < 1
            line_type = '-';
        end
    end
    
    dlat = maxlatg - minlatg;
    dlon = maxlong - minlong;
    
    % figure out the grid increment for latitude and longitude
    if fix(dlat / 5) >= 1
        latinc = infix(dlat / 5);
    else
        if 2.5 < round(dlat)  && round(dlat) <= 5
            latinc = 1;
        elseif 1.5 < round(dlat)  &&  round(dlat) <= 2.5
            latinc = 1/2;
        else
            latinc = 1/4;
        end
    end
    
    if fix(dlon / 5) >= 1
        loninc = infix(dlon / 5);
    else
        if 2.5 < round(dlon)  && round(dlon) <= 5
            loninc = 1;
        elseif 1.5 < round(dlon)  &&  round(dlon) <= 2.5
            loninc = 1/2;
        else
            loninc = 1/4;
        end
    end
    
    % figure out at which latitude/longitude the grid starts
    % This is the best trick I found to do this in one step!
    ylatgr1 = ceil(minlatg/latinc)*latinc;
    xlongr1 = ceil(minlong/loninc)*loninc;
    
    % plot the parallel grid & labels
    k = 1;
    while ylatgr1 + (latinc * (k-1)) < maxlatg
        xlatgr = minlong:dlon/99:maxlong;
        ylatgr = ones(1,100) .* (ylatgr1 + (latinc * (k-1)));
        [x, y] = lc_tocart(ylatgr,xlatgr);
        plot(x,y,'LineWidth',line_width,'LineStyle',line_type)
        text(x(1),y(1),[num2str(ylatgr(1)) blanks(1)],'Units','data',...
            'HorizontalAlignment','right','VerticalAlignment','middle',...
            'FontWeight','bold','FontSize',12)
        k = k + 1;
    end
    
    % plot the meridian grid & labels
    k = 1;
    while xlongr1 + (loninc * (k-1)) < maxlong
        xlongr = ones(1,100) .* (xlongr1 + (loninc * (k-1)));
        ylongr = minlatg:dlat/99:maxlatg;
        [x, y] = lc_tocart(ylongr,xlongr);
        plot(x,y,'LineWidth',line_width,'LineStyle',line_type)
        text(x(1),y(1),[num2str(xlongr(1),5) blanks(1)],'Units','data',...
            'HorizontalAlignment','center','VerticalAlignment','top',...
            'FontWeight','bold','FontSize',12)
        
        k = k + 1;
    end
    
end
