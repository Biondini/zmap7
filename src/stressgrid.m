function bvg = stressgrid() % autogenerated function wrapper
    % stressgrid create a grid (interactively), calculate stress tensor using Michaels or Gephards code
    %
    % Incoming data:
    % requires catalog contains 
    %   * DipDirection (East of North) 
    %   * Dip, 
    %   * Rake (Kanamori Convention)
    %
    % original: Stefan Wiemer 1/95
    %
    % updated by: J. Woessner
    % turned into function by Celso G Reyes 2017
    
    ZG=ZmapGlobal.Data; % used by get_zmap_globals
    
    report_this_filefun(mfilename('fullpath'));
    fs=filesep;
    
    % get the grid parameter
    % initial values
    %
   
    
    dx = 0.1;
    dy = 0.1 ;
    ni = 50;
    ra = ZG.ra;
    Nmin = 0;
    
    zdlg = ZmapDialog();
    zdlg.AddBasicPopup('calcmethod','Calc Method',{'Michaels Method'},1,...
        'Choose the only method that is available. (sorry, no other options)');
    
    zdlg.AddGridParameters('Grid',dx,'deg',dy,'deg',[],'');
    zdlg.AddEventSelectionParameters('EventSelector', ni, ra, Nmin)
    [res, okpressed]=zdlg.Create('Stress grid');
    if ~okpressed
        return
    end
    disp(res)
    Grid=res.Grid;
    EventSelector=res.EventSelector;
    ZG.inb1=res.calcmethod;
    my_calculate();

    
    function my_calculate()
        % get the grid-size interactively and
        % calculate the b-value in the grid by sorting
        % thge seimicity and selectiong the ni neighbors
        % to each grid point
        
        % get new grid if needed

        Grid=ZmapGrid('stressgrid',Grid);
        
        
        
        hodis = fullfile(ZG.hodi, 'external');
        cd(hodis);
        ReturnFields={'S1Trend','S1Plunge',...
            'S2Trend','S2Plunge',...
            'S3Trend','S3Plunge',...
            'Variance','Radius_km','b_value'};
        
        % calculate at all points
        [bvg,nEvents,maxDists,maxMag, ll]=gridfun(@calculation_function,...
            ZG.primeCatalog,Grid, EventSelector, numel(ReturnFields));
        
            bvg(:,strcmp('Radius_km',ReturnFields))=maxDists;
     
        % prepare output to desktop
        obj=struct();
        obj.Result.values=array2table(bvg,'VariableNames',ReturnFields);
        obj.Result.InCatalogName={'primeCatalog'};
        obj.Result.OutCatalogName='';
        obj.Result.Grid=Grid;
        obj.Result.EventSelector=EventSelector;
        assignin('base','stressgrid_result',obj.Result);
        
        view_stressmap(bvg)
        
        
        function bvg = calculation_function(b)
            % returns: S1Trend S1Plunge S2Trend S2Plunge S3Trend S3Plunge Variance Radius b-value
            
            %estimate the completeness and b-value
            % Take the focal mechanism from actual catalog
            % tmpi-input: [dip direction (East of North), dip , rake (Kanamori)]
            tmpi = [b.DipDirection, b.Dip, b.Rake];
            
            % Create file for inversion
            fid = fopen('data2','w');
            str = ['Inversion data'];str = str';
            fprintf(fid,'%s  \n',str');
            fprintf(fid,'%7.3f  %7.3f  %7.3f\n',tmpi');
            fclose(fid);
            
            % slick calculates the best solution for the stress tensor according to
            % Michael(1987): creates data2.oput
            switch computer
                case 'GLNX86'
                    unix(['".' fs 'slick_linux" data2 ']);
                case 'MAC'
                    unix(['".' fs 'slick_macppc" data2 ']);
                case 'MACI'
                    unix(['".' fs 'slick_maci" data2 ']);
                case 'MACI64'
                    unix(['".' fs 'slick_maci64" data2 ']);
                otherwise
                    dos(['".' fs 'slick.exe" data2 ']);
            end
            %unix([ZG.hodi fs 'external/slick data2 ']);
            % Get data from data2.oput
            sFilename = 'data2.oput';
            [fBeta, fStdBeta, fTauFit, fAvgTau, fStdTau] = import_slickoput(sFilename);
            
            % Delete existing data2.slboot
            
            sData2 = fullfile(ZG.hodi, 'external', 'data2.slboot');
            
            delete(sData2);
            
            % Stress tensor inversion
            switch computer
                case 'GLNX86'
                    unix(['"' ZG.hodi fs 'external/slfast_linux" data2 ']);
                case 'MAC'
                    unix(['"' ZG.hodi fs 'external/slfast_macpcc" data2 ']);
                case 'MACI'
                    unix(['"' ZG.hodi fs 'external/slfast_maci" data2 ']);
                case 'MACI64'
                    unix(['"' ZG.hodi fs 'external/slfast_maci64" data2 ']);
                otherwise
                    dos(['"' ZG.hodi fs 'external' fs 'slfast.exe" data2 ']);
            end
            %unix([ZG.hodi fs 'external/slfast data2 ']);
            sGetFile = fullfile(ZG.hodi, 'external', 'data2.slboot');
            d0=load(sGetFile,'data2');
            % Description of data2
            % Line 1: Variance S11 S12 S13 S22 S23 S33 => Variance and components of
            % stress tensor (S = sigma)
            % Line 2: Phi S1t S1p S2t S2p S3t S3p
            % Phi is relative size S3/S1, t=trend, p=plunge (other description)
            % d0 = tmp.data2;
            
            % Result matrix
            % S1Trend S1Plunge S2Trend S2Plunge S3Trend S3Plunge Variance Radius bvalue
            bvg = [d0(2,2:7) d0(1,1) nan nan];
        end
    end
    
end


function view_stressmap(bvg) % autogenerated function wrapper
    % view_stressmap
    % pulled into function due to its tight bonding from an m file
    % Author: S. Wiemer
    % updated: 19.05.2005, j.woessner@sed.ethz.ch
    % turned into function by Celso G Reyes 2017
    %TOFIX this has never been updated
    ZG=ZmapGlobal.Data;
    SA = 1;
    SA2 = 3;
    % Matrix bvg contains:
    % bvg : [S1Trend S1Plunge S2Trend S2Plunge S3Trend S3Plunge Variance Radius b-value]
    % ste : [S1Plunge S1Trend+180 S2Plunge S2Trend+180 S3Plunge S3Trend+180 Variance];
    ste = [bvg(:,2) bvg(:,1)+180  bvg(:,4) bvg(:,3)+180 bvg(:,6) bvg(:,5)+180 bvg(:,7) ];
    sor = ste;
    % sor : [S1Plunge S1Trend+270 S2Plunge S2Trend+180 S3Plunge S3Trend+180 Variance];
    sor(:,SA*2) = sor(:,SA*2)+90;
    
    % Create matrices
    normlap2=NaN(length(tmpgri(:,1)),1);
    
    valueMap=reshape(normlap2,length(yvect),length(xvect));
    s11 = valueMap;
    
    normlap2(ll)= bvg(:,8);
    rama=reshape(normlap2,length(yvect),length(xvect));
    
    normlap2(ll)= bvg(:,7);
    r=reshape(normlap2,length(yvect),length(xvect));
    
    normlap2(ll)= bvg(:,1);
    s11=reshape(normlap2,length(yvect),length(xvect));
    
    normlap2(ll)= bvg(:,4);
    s31=reshape(normlap2,length(yvect),length(xvect));
    
    normlap2(ll)= bvg(:,2);
    s12=reshape(normlap2,length(yvect),length(xvect));
    
    %old1 = valueMap;
    
    % Create figure
    figure_w_normalized_uicontrolunits('visible','off')
    l_normal =  ste(:,1) > 52 &   ste(:,5) < 35 ;
    l_notnormal = l_normal < 1;
    
    plq = quiver(newgri(l_notnormal,1),newgri(l_notnormal,2),-cos(sor(l_notnormal,SA*2)*pi/180),sin(sor(l_notnormal,SA*2)*pi/180),0.6,'.');
    set(plq,'LineWidth',0.5,'Color','k')
    px = get(plq,'Xdata');
    py = get(plq,'Ydata');
    
    close
    
    
    figure_w_normalized_uicontrolunits('visible','off')
    
    plq_n = quiver(newgri(l_normal,1),newgri(l_normal,2),-cos(sor(l_normal,SA2*2)*pi/180),sin(sor(l_normal,SA2*2)*pi/180),0.6,'.');
    set(plq_n,'LineWidth',0.5,'Color','r')
    
    drawnow
    px_n = get(plq_n,'Xdata');
    py_n = get(plq_n,'Ydata');
    close
    
    figure_w_normalized_uicontrolunits('Name','Faulting style map','pos',[100 100 860 600])
    watchon;
    %whitebg(gcf);
    set(gcf,'color','w');
    axes('pos',[0.12 0.12 0.8 0.8]);
    hold on
    n = 0;
    l0 = []; l1 = []; l2 = []; l3 = []; l4 = []; l5 = [];
    
    ste = sor(l_notnormal,:);
    for i = 1:3:length(px)-1
        n = n+1;j = jet;
        col = floor(ste(n,SA*2-1)/60*62)+1;
        if col > 64 ; col = 64; end
        pl = plot(px(i:i+1),py(i:i+1),'k','Linewidth',1.,'Markersize',1,'color',[ 0 0 0  ] );
        hold on
        
        dx = px(i)-px(i+1);
        dy = py(i) - py(i+1);
        pl2 = plot(px(i),py(i),'ko','Markersize',0.1,'Linewidth',0.5,'color',[0 0 0] );
        l0 = pl2;
        pl3 = plot([px(i) px(i)+dx],[py(i) py(i)+dy],'k','Linewidth',1.,'color',[0 0 0] );
        % Select faulting style according to Zoback(1992)
        if ste(n,1) < 40  && ste(n,3) > 45  && ste(n,5) < 20 ; set([pl pl3],'color',[0.2 0.8 0.2]); set(pl2,'color',[0.2 0.8 0.2]); l3 = pl; end
        if ste(n,1) < 20  && ste(n,3) > 45  && ste(n,5) < 40 ;  set([pl pl3],'color',[0.2 0.8 0.2]); set(pl2,'color',[0.2 0.8 0.2]);l3 = pl; end
        if ste(n,1) > 40  &&                 ste(n,1) < 52  && ste(n,5) < 20 ;  set([pl pl3],'color','m'); set(pl2,'color','m'); l2 = pl; end
        if ste(n,1) < 20  &&                 ste(n,5) > 40  &&  ste(n,5) <  52 ; set([pl pl3],'color','c'); set(pl2,'color','c');l4 = pl; end
        if ste(n,1) < 37  && ste(n,5) > 47  ; set([pl pl3],'color','b'); set(pl2,'color','b');l5 = pl;  end
        
    end
    %drawnow
    ste = sor(l_normal,:);
    n = 0;
    
    for i = 1:3:length(px_n)-1
        n = n+1;j = jet;
        col = floor(ste(n,SA*2-1)/60*62)+1;
        if col > 64 ; col = 64; end
        dx_n = px_n(i)-px_n(i+1);
        dy_n= py_n(i) - py_n(i+1);
        pl_n = plot(px_n(i:i+1),py_n(i:i+1),'k','Linewidth',1.,'Markersize',1,'color',[ 0 0 0  ] );
        hold on
        dx = px_n(i)- px_n(i+1);
        dy = py_n(i) - py_n(i+1);
        pl2_n = plot(px_n(i),py_n(i),'ko','Markersize',0.1,'Linewidth',0.5,'color',[0 0 0] );
        l0 = pl2;
        pl3_n = plot([px_n(i) px_n(i)+dx_n],[py_n(i) py_n(i)+dy_n],'k','Linewidth',1.,'color',[0 0 0] );
        
        if ste(n,1) > 52  &&                 ste(n,5) < 35 ;                 set([pl_n pl3_n],'color','r'); set(pl2_n,'color','r'); l1 = pl_n;
        end
    end
    
    if isempty(l1); pl2 = plot(px,py,'kx','Linewidth',1.,'color','r'); l1 = pl2; set(l1,'visible','off'); end
    if isempty(l2); pl2 = plot(px,py,'kx','Linewidth',1.,'color','m'); l2 = pl2; set(l2,'visible','off'); end
    if isempty(l3); pl2 = plot(px,py,'kx','Linewidth',1.,'color',[0.2 0.8 0.2] ); l3 = pl2; set(l3,'visible','off'); end
    if isempty(l4); pl2 = plot(px,py,'kx','Linewidth',1.,'color','c' ); l4 = pl2; set(l4,'visible','off'); end
    if isempty(l5); pl2 = plot(px,py,'kx','Linewidth',1.,'color','b' ); l5 = pl2; set(l5,'visible','off'); end
    if isempty(l0); l0 = plot(px,py,'kx','Linewidth',1.,'color',[0 0 0 ] );  set(l0,'visible','off'); end
    
    try
        legend([l1 l2 l3 l4 l5 l0],'NF','NS','SS','TS','TF','U');
    catch
        disp('Legend could not be drawn')
    end
    
    % Figure settings
    hold on
    axis('equal')
    zmap_update_displays();
    set(gca,'aspectratio',[0.827 1])
    axis([ s2 s1 s4 s3])
    title([name ';  '   num2str(t0b) ' to ' num2str(teb) ],'FontSize',ZmapGlobal.Data.fontsz.s,...
        'Color','k','FontWeight','normal');
    mygca = gca;
    xlabel('Longitude ','FontWeight','normal','FontSize',ZmapGlobal.Data.fontsz.s)
    ylabel('Latitude ','FontWeight','normal','FontSize',ZmapGlobal.Data.fontsz.s)
    set(gca,'visible','on','FontSize',ZmapGlobal.Data.fontsz.s,'FontWeight','normal',...
        'FontWeight','normal','LineWidth',1.,...
        'Box','on','TickDir','out','Ticklength',[0.01 0.01])
    
    watchoff;
    
    % View the variance map
    valueMap = r;ZG.shading_style = 'interp';
    view_varmap([],valueMap);
    
end