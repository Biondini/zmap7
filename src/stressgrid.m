function stressgrid(sel) % autogenerated function wrapper
    % Script: stressgrid.m
    %
    % Script to create a grid (interactively), calculate stress tensor using
    % Michaels or Gephards code
    %
    % Incoming data:
    % Columns 10-12 of newa must be
    % 10: dip direction (East of North
    % 11: dip
    % 12: rake (Kanamori convention)
    %
    % Output:
    % Matrix: bvg
    % original: Stefan Wiemer 1/95
    %
    % last update: J. Woessner, 15.02.2005
    % turned into function by Celso G Reyes 2017
    
    ZG=ZmapGlobal.Data; % used by get_zmap_globals
    
    report_this_filefun(mfilename('fullpath'));
    
    global inb1 inb2
    fs=filesep;
    ZG=ZmapGlobal.Data;
    if sel == 'in'
        % get the grid parameter
        % initial values
        %
        
        if size(a(1,:)) < 12
            errordlg('You need 12 columns of input data (i.e., fault plane solutions) to calculate a stress tensor!');
            return
        end
        
        dx = 0.1;
        dy = 0.1 ;
        ni = 50;
        Nmin = 0;
        stan2 = nan;
        stan = nan;
        prf = nan;
        av = nan;
        
        % make the interface
        %
        figure_w_normalized_uicontrolunits(...
            'Name','Grid Input Parameter',...
            'NumberTitle','off', ...
            'NextPlot','new', ...
            'units','points',...
            'Visible','on', ...
            'Position',[ 100 100 650 250]);
        axis off
        labelList2=[' Michaels Method | sorry, no other options'];
        labelPos = [0.2 0.8  0.6  0.08];
        hndl2=uicontrol(...
            'Style','popup',...
            'Position',labelPos,...
            'Units','normalized',...
            'String',labelList2,...
            'callback',@callbackfun_001);
        
        set(hndl2,'value',1);
        
        
        % creates a dialog box to input grid parameters
        %
        
        
        freq_field=uicontrol('Style','edit',...
            'Position',[.30 .60 .12 .08],...
            'Units','normalized','String',num2str(ni),...
            'callback',@callbackfun_002);
        
        
        freq_field0=uicontrol('Style','edit',...
            'Position',[.30 .50 .12 .08],...
            'Units','normalized','String',num2str(ra),...
            'callback',@callbackfun_003);
        
        freq_field2=uicontrol('Style','edit',...
            'Position',[.30 .40 .12 .08],...
            'Units','normalized','String',num2str(dx),...
            'callback',@callbackfun_004);
        
        freq_field3=uicontrol('Style','edit',...
            'Position',[.30 .30 .12 .080],...
            'Units','normalized','String',num2str(dy),...
            'callback',@callbackfun_005);
        
        tgl1 = uicontrol('Style','radiobutton',...
            'string','Number of Events:',...
            'Position',[.05 .60 .2 .0800], 'callback',@callbackfun_006,...
            'Units','normalized');
        
        set(tgl1,'value',1);
        
        tgl2 =  uicontrol('Style','radiobutton',...
            'string','OR: Constant Radius',...
            'Position',[.05 .50 .2 .080], 'callback',@callbackfun_007,...
            'Units','normalized');
        
        create_grid =  uicontrol('Style','radiobutton',...
            'string','Calculate a new grid', 'callback',@callbackfun_008,'Position',[.55 .55 .2 .080],...
            'Units','normalized');
        
        set(create_grid,'value',1);
        
        prev_grid =  uicontrol('Style','radiobutton',...
            'string','Reuse the previous grid', 'callback',@callbackfun_009,'Position',[.55 .45 .2 .080],...
            'Units','normalized');
        
        
        load_grid =  uicontrol('Style','radiobutton',...
            'string','Load a previously saved grid', 'callback',@callbackfun_010,'Position',[.55 .35 .2 .080],...
            'Units','normalized');
        
        save_grid =  uicontrol('Style','checkbox',...
            'string','Save selected grid to file',...
            'Position',[.55 .22 .2 .080],...
            'Units','normalized');
        
        freq_field4 = uicontrol('Style','edit',...
            'Position',[.30 .20 .12 .080],...
            'Units','normalized','String',num2str(Nmin),...
            'callback',@callbackfun_011);
        
        
        close_button=uicontrol('Style','Pushbutton',...
            'Position',[.60 .05 .15 .12 ],...
            'Units','normalized','callback',@callbackfun_012,'String','Cancel');
        
        go_button1=uicontrol('Style','Pushbutton',...
            'Position',[.20 .05 .15 .12 ],...
            'Units','normalized',...
            'callback',@callbackfun_013,...
            'String','Go');
        
        txt3 = text(...
            'Position',[0.30 0.75 0 ],...
            'FontSize',ZmapGlobal.Data.fontsz.l ,...
            'FontWeight','bold',...
            'String',' Grid Parameter');
        txt5 = text(...
            'Position',[-0.1 0.4 0 ],...
            'FontSize',ZmapGlobal.Data.fontsz.m ,...
            'FontWeight','bold',...
            'String','Spacing in x (dx) in deg:');
        
        txt6 = text(...
            'Position',[-0.1 0.3 0 ],...
            'FontSize',ZmapGlobal.Data.fontsz.m ,...
            'FontWeight','bold',...
            'String','Spacing in y (dy) in deg:');
        
        txt7 = text(...
            'Position',[-0.1 0.18 0 ],...
            'FontSize',ZmapGlobal.Data.fontsz.m ,...
            'FontWeight','bold',...
            'String','Min. no. of evts. (const R):');
        
        
        
        
        set(gcf,'visible','on');
        watchoff
        
    end   % if nargin ==0
    
    % get the grid-size interactively and
    % calculate the b-value in the grid by sorting
    % thge seimicity and selectiong the ni neighbors
    % to each grid point
    
    if sel == 'ca'
        % get new grid if needed
        if load_grid == 1
            [file1,path1] = uigetfile(['*.mat'],'previously saved grid');
            if length(path1) > 1
                think
                load([path1 file1])
                plot(newgri(:,1),newgri(:,2),'k+')
            end
        elseif load_grid ==0  &&  prev_grid == 0
            selgp
            if length(gx) < 4  ||  length(gy) < 4
                errordlg('Selection too small! (Dx and Dy are in degreees! ');
                return
            end
        end
        
        if save_grid == 1
            grid_save =...
                [ 'zmap_message_center.set_info(''Saving Grid'',''  '');think;',...
                '[file1,path1] = uiputfile(fullfile(ZmapGlobal.Data.data_dir,''*.mat''), ''Grid File Name?'') ;',...
                ' gs = [''save '' path1 file1 '' newgri dx dy gx gy xvect yvect tmpgri ll''];',...
                ' if length(file1) > 1, eval(gs),end , done']; eval(grid_save)
        end
        
        
        itotal = length(newgri(:,1));
        
        zmap_message_center.set_info(' ','Running... ');think
        %  make grid, calculate start- endtime etc.  ...
        %
        t0b = min(ZG.a.Date)  ;
        n = ZG.a.Count;
        teb = max(ZG.a.Date) ;
        tdiff = round((teb-t0b)/ZG.bin_days);
        loc = zeros(3, length(gx)*length(gy));
        
        % loop over  all points
        %
        i2 = 0.;
        i1 = 0.;
        bvg = [];
        allcount = 0.;
        wai = waitbar(0,' Please Wait ...  ');
        set(wai,'NumberTitle','off','Name','stress map grid - percent done');;
        drawnow
        %
        % create bvg
        bvg = zeros(length(newgri),9)*nan;
        
        
        hodis = fullfile(ZG.hodi, 'external');
        cd(hodis);
        
        % loop over all points
        for i= 1:length(newgri(:,1))
            x = newgri(i,1);y = newgri(i,2);
            allcount = allcount + 1.;
            i2 = i2+1;
            
            % calculate distance from center point and sort wrt distance
            l=ZG.a.epicentralDistanceTo(x,y);
            [s,is] = sort(l);
            b = a(is(:,1),:) ;       % re-orders matrix to agree row-wise
            
            if tgl1 == 0   % take point within r
                l3 = l <= ra;
                b = ZG.a.subset(l3);      % new data per grid point (b) is sorted in distance
                rd = ra;
            else
                % take first ni points
                b = b(1:ni,:);      % new data per grid point (b) is sorted in distance
                l2 = sort(l); rd = l2(ni);
                
            end
            
            
            %estimate the completeness and b-value
            ZG.newt2 = b;
            if length(b) >= Nmin  % enough events?
                % Take the focal mechanism from actual catalog
                % tmpi-input: [dip direction (East of North), dip , rake (Kanamori)]
                tmpi = [ZG.newt2(:,10:12)];
                
                % Create file for inversion
                fid = fopen('data2','w');
                str = ['Inversion data'];str = str';
                fprintf(fid,'%s  \n',str');
                fprintf(fid,'%7.3f  %7.3f  %7.3f\n',tmpi');
                fclose(fid);
                
                % slick calculates the best solution for the stress tensor according to
                % Michael(1987): creates data2.oput
                switch computer
                    case 'GLNX86'
                        unix(['".' fs 'slick_linux" data2 ']);
                    case 'MAC'
                        unix(['".' fs 'slick_macppc" data2 ']);
                    case 'MACI'
                        unix(['".' fs 'slick_maci" data2 ']);
                    case 'MACI64'
                        unix(['".' fs 'slick_maci64" data2 ']);
                    otherwise
                        dos(['".' fs 'slick.exe" data2 ']);
                end
                %unix([ZG.hodi fs 'external/slick data2 ']);
                % Get data from data2.oput
                sFilename = ['data2.oput'];
                [fBeta, fStdBeta, fTauFit, fAvgTau, fStdTau] = import_slickoput(sFilename);
                
                % Delete existing data2.slboot
                
                sData2 = fullfile(ZG.hodi, 'external', 'data2.slboot');
                
                delete(sData2);
                
                % Stress tensor inversion
                switch computer
                    case 'GLNX86'
                        unix(['"' ZG.hodi fs 'external/slfast_linux" data2 ']);
                    case 'MAC'
                        unix(['"' ZG.hodi fs 'external/slfast_macpcc" data2 ']);
                    case 'MACI'
                        unix(['"' ZG.hodi fs 'external/slfast_maci" data2 ']);
                    case 'MACI64'
                        unix(['"' ZG.hodi fs 'external/slfast_maci64" data2 ']);
                    otherwise
                        dos(['"' ZG.hodi fs 'external' fs 'slfast.exe" data2 ']);
                end
                %unix([ZG.hodi fs 'external/slfast data2 ']);
                sGetFile = fullfile(ZG.hodi, 'external', 'data2.slboot');
                load(sGetFile); % Creates variable data2 in workspace
                % Description of data2
                % Line 1: Variance S11 S12 S13 S22 S23 S33 => Variance and components of
                % stress tensor (S = sigma)
                % Line 2: Phi S1t S1p S2t S2p S3t S3p
                % Phi is relative size S3/S1, t=trend, p=plunge (other description)
                d0 = data2;
                
                bv2 = nan;
                % Result matrix
                % S1Trend S1Plunge S2Trend S2Plunge S3Trend S3Plunge Variance Radius b-value
                bvg(allcount,:) = [d0(2,2:7) d0(1,1) rd bv2];
            end % if Nmin
            waitbar(allcount/itotal)
        end  % for newgr
        close(wai)
        watchoff
        view_stressmap
    end
    
    function callbackfun_001(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        inb2=hndl2.Value;
    end
    
    function callbackfun_002(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        update_editfield_value(mysrc);
        ni=mysrc.Value;
        tgl2.Value=0;
        tgl1.Value=1;
    end
    
    function callbackfun_003(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        update_editfield_value(mysrc);
        ra=mysrc.Value;
        tgl2.Value=1;
        tgl1.Value=0;
    end
    
    function callbackfun_004(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        update_editfield_value(mysrc);
        dx=mysrc.Value;
    end
    
    function callbackfun_005(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        update_editfield_value(mysrc);
        dy=mysrc.Value;
    end
    
    function callbackfun_006(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        tgl2.Value=0;
    end
    
    function callbackfun_007(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        tgl1.Value=0;
    end
    
    function callbackfun_008(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        load_grid.Value=0;
        prev_grid.Value=0;
    end
    
    function callbackfun_009(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        load_grid.Value=0;
        create_grid.Value=0;
    end
    
    function callbackfun_010(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        prev_grid.Value=0;
        create_grid.Value=0;
    end
    
    function callbackfun_011(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        update_editfield_value(mysrc);
        Nmin=mysrc.Value;
    end
    
    function callbackfun_012(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        close;
        done;
    end
    
    function callbackfun_013(mysrc,myevt)
        % automatically created callback function from text
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        inb1=hndl2.Value;
        tgl1=tgl1.Value;
        tgl2=tgl2.Value;
        prev_grid=prev_grid.Value;
        create_grid=create_grid.Value;
        load_grid=load_grid.Value;
        save_grid=save_grid.Value;
        close;
        sel ='ca';
        stressgrid;
    end
    
end
