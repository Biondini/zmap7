function bdiff2() % autogenerated function wrapper
    % bdiff2 estimates the b-value of a curve automatically
    % The b-value curve is differenciated and the point
    % of the magnitude of completeness is marked. The b-value will be calculated
    % using this point and the point half way toward the high
    % magnitude end of the b-value curve.
    %
    % 
    % Formerly : function  bdiff(newcat)
    % Stefan Wiemer 1/95
    % upadated: J.Woessner, 27.08.04
    % turned into function by Celso G Reyes 2017
    
    %TODO change this over to a ZmapFunction
    
    ZG=ZmapGlobal.Data; % used by get_zmap_globals
    
    % Changes record:
    % 02.06.03: Added choice of EMR-method to calculate Mc
    % 06.10.03: Added choice of MBS-method to calculate Mc (fixed at 5)
    %           Added bootstrap choice
    % 28.07.04: Many changes: Now able to do computatios with all functions
    %           available in calc_Mc
    
    global magsteps_desc bvalsum3  bval aw bw; %bfig
    global  cua ew onesigma b;
    global gBdiff % contains b1, n1, b2, n2
    global magco bv;
    global hndl2 inpr1;
    ZG=ZmapGlobal.Data;
    
    report_this_filefun(mfilename('fullpath'));
    
    % Default value
    nBstSample = 100;
    fMccorr = 0;
    fBinning = 0.1;
    
    
    %% new dialog
    zdlg = ZmapDialog();
    zdlg.AddBasicHeader('Magnitude of Completness parameters');
    zdlg.AddBasicPopup('mc_method','Max. likelihood Estimation',calc_Mc,1,'Choose Magnitude of completion calculation method');
    zdlg.AddBasicEdit('fMccorr','Mc Correction',fMccorr,'Correction term for Magnitude of Completeness');
    zdlg.AddBasicCheckbox('doBootstrap','Uncertainty by bootstrapping',false,{'nBstSample'},'tooltip');
    zdlg.AddBasicEdit('nBstSample','Bootstraps',nBstSample,'Number of bootstraps used to estimate error');
    zdlg.AddBasicCheckbox('doLinearityCheck','Perform Nonlinearity check on B-values',false,[],'tooltip');
    [dlg_res, pressedOk] = zdlg.Create('Mc Input Parameter');
    if ~pressedOk
        return
    end
    % reassign variables
    ZG.inb2 = dlg_res.mc_method;
    fMccorr = dlg_res.fMccorr;
    nBstSample = dlg_res.nBstSample;
    inpr1 = dlg_res.mc_method;
    doBootstrap = dlg_res.doBootstrap;
    doLinearityCheck = dlg_res.doLinearityCheck;
    
    my_calculate();
    
    function my_calculate()
        
        %%
        %
        % check to see if figure exists
        % if does -- draw over
        % if it does not, create the window
        %
        %%
        
        bfig=findobj('Type','Figure','-and','Name','Frequency-magnitude distribution');
        if isempty(bfig)
            bfig=figure_w_normalized_uicontrolunits(...                  %build figure for plot
                'Units','normalized','NumberTitle','off',...
                'Name','Frequency-magnitude distribution',...
                'visible','off',...
                'pos',[ 0.300  0.3 0.4 0.6]);
            
            ZG.hold_state=false;
            
            create_my_menu()
        end % existflag
        
        maxmag = ceil(10*max(ZG.newt2.Magnitude))/10;
        mima = min(ZG.newt2.Magnitude);
        if mima > 0 ; mima = 0 ; end
        
        
        %%
        %
        % bval contains the number of events in each bin
        % bvalsum is the cum. sum in each bin
        % bval2 is number events in each bin, in reverse order
        % bvalsum3 is reverse order cum. sum.
        % magsteps_desc is the step in magnitude for the bins == .1
        %
        %%
        
        [bval,xt2] = hist(ZG.newt2.Magnitude,(mima:0.1:maxmag));
        bvalsum = cumsum(bval); % N for M <=
        bval2 = bval(end:-1:1);
        bvalsum3 = cumsum(bval(end:-1:1));    % N for M >= (counted backwards)
        magsteps_desc = (maxmag:-0.1:mima);
        
        backg_ab = log10(bvalsum3);
        
        if ZG.hold_state
            axes(cua)
            disp('hold on')
            hold on
        else
            figure(bfig);
            delete(findobj(bfig,'Type','axes'));
            rect = [0.22,  0.3, 0.65, 0.6];           % plot Freq-Mag curves
            axes('position',rect);
        end % ZmapGlobal.Data.hold_state
        
        %%
        % plot the cum. sum in each bin  %%
        %%
        
        pl =semilogy(magsteps_desc,bvalsum3,'sb');
        set(pl,'LineWidth',1.0,'MarkerSize',6,...
            'MarkerFaceColor','w','MarkerEdgeColor','k');
        hold on
        pl1 =semilogy(magsteps_desc,bval2,'^b');
        set(pl1,'LineWidth',1.0,'MarkerSize',4,...
            'MarkerFaceColor',[0.7 0.7 .7],'MarkerEdgeColor','k');
        
        %%
        % CALCULATE the diff in cum sum from the previous biin
        %%
        
        
        xlabel('Magnitude','FontWeight','bold','FontSize',ZmapGlobal.Data.fontsz.m)
        ylabel('Cumulative Number','FontWeight','bold','FontSize',ZmapGlobal.Data.fontsz.m)
        set(gca,'visible','on','FontSize',ZmapGlobal.Data.fontsz.m,'FontWeight','normal',...
            'FontWeight','bold','LineWidth',1.0,'TickDir','out','Ticklength',[0.02 0.02],...
            'Box','on','Tag','cufi','color','w')
        
        cua = gca;
        
        %%
        % Estimate the b value
        %
        % calculates max likelihood b value(bvml) && WLS(bvls)
        %
        %%
        
        %% SET DEFAULTS TO BE ADDED INTERACTIVLY LATER
        Nmin = 10;
        
        bvs=ZG.newt2;
        b=ZG.newt2;
        
        %% enough events??
        [fMc, fStd_Mc, fBValue, fStd_B, fAValue, fStd_A] = deal(NaN);
        if bvs.Count >= Nmin
            % Added to obtain goodness-of-fit to powerlaw value
            [Mc, Mc90, Mc95, magco, prf]=mcperc_ca3();
            
            fMc = calc_Mc(bvs, inpr1, fBinning, fMccorr);
            l = bvs.Magnitude >= fMc-(fBinning/2);
            if sum(l) >= Nmin
                [ fBValue, fStd_B, fAValue] =  calc_bmemag(bvs.subset(l), fBinning);
            else
                fMc = NaN;
            end
            
            % Bootstrap uncertainties
            if doBootstrap
                % Check Mc from original catalog
                l = bvs.Magnitude >= fMc-(fBinning/2);
                if sum(l) >= Nmin
                    [fMc, fStd_Mc, fBValue, fStd_B, fAValue, fStd_A, vMc, mBvalue] = calc_McBboot(bvs, fBinning, nBstSample, inpr1, Nmin, fMccorr);
                end
            end
        end% of if length(bvs) >= Nmin
         
        %% calculate limits of line to plot for b value line
         
        % For ZMAP
        magco = fMc;
        index_low=find(magsteps_desc < magco+.05 & magsteps_desc > magco-.05);
        
        mag_hi = magsteps_desc(1);
        index_hi = 1;
        mz = magsteps_desc <= mag_hi & magsteps_desc >= magco-.0001;
        mag_zone=magsteps_desc(mz);
        
        y = backg_ab(mz);
        
        %% Marks the point of Mc
        
        te = semilogy(magsteps_desc(index_low),bvalsum3(index_low)*1.5,'vb');
        set(te,'LineWidth',1.0,'MarkerSize',7)
        
        te = text(magsteps_desc(index_low)+0.2,bvalsum3(index_low)*1.5,'Mc');
        set(te,'FontWeight','bold','FontSize',ZmapGlobal.Data.fontsz.s,'Color','b')
        
        
        %% Set to correct method, maximum like or least squares
        
        if doBootstrap
            sol_type = 'Maximum Likelihood Estimate, Uncertainties by bootstrapping';
        else
            sol_type = 'Maximum Likelihood Solution';
        end
        
        bw=fBValue;%bvml;
        aw=fAValue;%avml;
        ew=fStd_B;%stanml;
            
        
        %% create and draw a line corresponding to the b value
        
        figure(bfig);
        %p = [ -1*bw aw];
        p = [ -1*bw aw];
        %[p,S] = polyfit(mag_zone,y,1);
        f = polyval(p,mag_zone);
        f = 10.^f;
        hold on
        ttm= semilogy(mag_zone,f,'r');   % plot linear fit to backg
        set(ttm,'LineWidth',1.)
        std_backg = ew;      % standard deviation of fit
        
         
        %% Error Bar Calculation -- call to pdf_calc.m
         
        
        %pdf_calc;
        set(gca,'XLim',[min(b.Magnitude)-0.5  max(b.Magnitude)+0.5])
        set(gca,'YLim',[0.9 length(b.Date+30)*2.5]);
        
        
        p=-p(1,1);
        p=fix(100*p)/100;
        tt1=num2str(bw,3);
        tt2=num2str(std_backg,1);
        tt4=num2str(bv,3);
        tt5=num2str(onesigma,2);
        
        
        tmc=num2str(magco,2);
        
        rect=[0 0 1 1];
        h2=axes('position',rect);
        set(h2,'visible','off');
        
        a0 = aw-log10(years(max(b.Date)-min(b.Date)));
        
        
        if ZG.hold_state
            set(pl,'LineWidth',1.0,'MarkerSize',8,...
                'MarkerFaceColor','k','MarkerEdgeColor','k','Marker','^');
            %set(pl3,'LineWidth',1.0,'MarkerSize',6,...
            %'MarkerFaceColor','c','MarkerEdgeColor','m','Marker','s');
            %   txt1=text(.16, .06,['b-value (w LS, M  >= ', num2str(M1b(1)) '): ',tt1, ' +/- ', tt2 ',a-value = ' , num2str(aw) ]);
            set(txt1,'FontWeight','normal','FontSize',ZmapGlobal.Data.fontsz.s,'Color','r')
        else
            if ~doBootstrap
                txt1=text(.16, .11,['b-value = ',tt1,' +/- ',tt2,',  a value = ',num2str(aw,3) ',  a value (annual) = ', num2str(a0,3)],'FontSize',ZmapGlobal.Data.fontsz.s);
                set(txt1,'FontWeight','normal')
                set(gcf,'PaperPosition',[0.5 0.5 4.0 5.5])
                text(.16, .14,sol_type,'FontSize',ZmapGlobal.Data.fontsz.s );
                text(.16, .08,['Magnitude of Completeness = ',tmc],'FontSize',ZmapGlobal.Data.fontsz.s);
            else
                txt1=text(.16, .11,['b-value = ',num2str(round(100*fBValue)/100),' +/- ',num2str(round(100*fStd_B)/100),',  a value = ',num2str(aw,3) ',  a value (annual) = ', num2str(a0,3)],'FontSize',ZmapGlobal.Data.fontsz.s);
                set(txt1,'FontWeight','normal')
                set(gcf,'PaperPosition',[0.5 0.5 4.0 5.5])
                text(.16, .14,sol_type,'FontSize',ZmapGlobal.Data.fontsz.s );
                text(.16, .08,['Magnitude of Completeness = ',tmc ' +/- ', num2str(round(100*fStd_Mc)/100)],'FontSize',ZmapGlobal.Data.fontsz.s);
            end
        end % ZmapGlobal.Data.hold_state
        
        set(gcf,'visible','on','Color','w');
        
        
        if ZG.hold_state
            % calculate the probability that the two distributins are differnt
            %l = ZG.newt2.Magnitude >=  M1b(1);
            gBdiff.b2 = str2double(tt1); gBdiff.n2 = M1b(2);
            n = gBdiff.n1+gBdiff.n2;
            da = -2*n*log(n) + 2*gBdiff.n1*log(gBdiff.n1+gBdiff.n2*gBdiff.b1/gBdiff.b2) + 2*gBdiff.n2*log(gBdiff.n1*gBdiff.b2/gBdiff.b1+gBdiff.n2) -2;
            pr = exp(-da/2-2);
            disp(['Probability: ',  num2str(pr)]);
            txt1=text(.60, .85,['p=  ', num2str(pr,2)],'Units','normalized');
            set(txt1,'FontWeight','normal','FontSize',ZmapGlobal.Data.fontsz.s)
            txt1=text(.60, .80,[ 'n1: ' num2str(gBdiff.n1) ', n2: '  num2str(gBdiff.n2) ', b1: ' num2str(gBdiff.b1)  ', b2: ' num2str(gBdiff.b2)]);
            set(txt1,'FontSize',8,'Units','normalized')
        end
        if doLinearityCheck
            cb_nonlin_keepmc();
        end
    end
    
    
    %% ui functions
    function create_my_menu()
        add_menu_divider();
        options = uimenu('Label','ZTools');
        uimenu(options,'Label','Estimate recurrence time/probability', 'callback',@callbackfun_recurrence);
        % uimenu(options,'Label','Manual fit of b-value', 'callback',@callbackfun_manual_fit);
        uimenu(options,'Label','Plot time series', 'callback',@callbackfun_ts);
        uimenu(options,'Label','Examine Nonlinearity (optimize  Mc)','Callback',@cb_nonlin_optimize);
        uimenu(options,'Label','Examine Nonlinearity (Keep Mc)','Callback',@cb_nonlin_keepmc);
        uimenu(options,'Label','Do not show discrete curve', 'callback',@callbackfun_nodiscrete);
        uimenu(options,'Label','Save values to file', 'Callback',{@calSave9,magsteps_desc, bvalsum3});
    end
    
    %% callback functions
    
    %{
    % WHY does this reset the hndl2.Value (?)
    function callbackfun_003(mysrc,myevt)
        fMccorr=str2double(field2.String);
        field2.String=num2str(fMccorr);
        hndl2.Value=1;
    end
    %}
    
    function callbackfun_recurrence(mysrc,myevt)
        plorem(onesigma, aw, bw); 
    end
    
    function callbackfun_manual_fit(mysrc,myevt)
        bfitnew(ZG.newcat);
    end
    
    function callbackfun_ts(mysrc,myevt)
        ZG.newcat = ZG.newt2;
        timeplot();
    end
    
    function callbackfun_nodiscrete(mysrc,myevt)
        % toggles discrete curve
        isChecked = strcmp(mysrc.Checked,'on');
        mysrc.Checked = logical2onoff(~isChecked);
        pl1.Visible = logical2onoff(mysrc.Checked);
    end
    
    function cb_nonlin_optimize(mysrc, myevt)
        [Results.bestmc,Results.bestb,Results.result_flag] = nonlinearity_index(ZG.newt2, magco, 'OptimizeMc');
        Results.functioncall = sprintf('nonlinearity_index(ZG.newt2,%.1f,''OptimizeMc'')',magco);
        assignin('base','Results_NonlinearityAnalysis',Results);
    end
    function cb_nonlin_keepmc(mysrc, myevt)
        [Results.bestmc,Results.bestb,Results.result_flag]=nonlinearity_index(ZG.newt2, magco, 'PreDefinedMc');
        Results.functioncall = sprintf('nonlinearity_index(ZG.newt2,%.1f,''PreDefinedMc'')',magco);
        assignin('base','Results_NonlinearityAnalysis',Results);
    end
    
end
