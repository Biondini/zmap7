function newsta(sta) % autogenerated function wrapper
    %  A as(t) value is calculated for a given cumulative number curve and displayed in the plot.
    %  Operates on catalogue ZG.newcat
    % turned into function by Celso G Reyes 2017
    
    ZG=ZmapGlobal.Data; % used by get_zmap_globals
    
    
    % start and end time
    NuBins=[]; NuRep=[]% declare for functions that share this variable
    think
    report_this_filefun(mfilename('fullpath'));
    b = ZG.newcat;
    
    %select big evenets
    l = ZG.newt2.Magnitude > ZG.big_eq_minmag;
    big = ZG.newt2.subset(l);
    
    [ZG.compare_window_yrs, ZG.bin_days] = choose_parameters(ZG.compare_window_yrs, ZG.bin_days); % window length, bin length
    
    
    t0b = min(ZG.newt2.Date); % changed from ZG.a.Date
    teb = max(ZG.newt2.Date); % changed from ZG.a.Date
    tdiff = round((teb - t0b)/ZG.bin_days); % in days/ZG.bin_days
    
    % for hist, xt & 2nd parameter were centers.  for histcounts, it is edges.
    [cumu, xt] = histcounts(ZG.newt2.Date, t0b: ZG.bin_days :teb);
    xt = xt + (xt(2)-xt(1))/2; xt(end)=[]; % convert from edges to centers!
    cumu2=cumsum(cumu);
    
    
    %  winlen_days is the cutoff at the beginning and end of the analyses to avoid spikes at the end
    % winlen_days = 10;
    
    
    % calculate mean and z value
    
    ncu = length(xt);
    as = nan(1,ncu);
    
    winlen_days = floor(days(years(ZG.compare_window_yrs)/days(ZG.bin_days)));
    probabilityButtonCallback=[];
    switch sta
        case 'rub'
            for i = winlen_days:1:tdiff-winlen_days
                mean1 = mean(cumu(1:i));
                mean2 = mean(cumu(i+1:i+winlen_days));
                var1 = cov(cumu(1:i));
                var2 = cov(cumu(i+1:i+winlen_days));
                as(i) = (mean1 - mean2)/(sqrt(var1/i+var2/winlen_days));
                titletext=['Rubberband Function; wl = ', num2str(ZG.compare_window_yrs)];
            end
        case 'ast'
            for i = floor(winlen_days):floor(tdiff-winlen_days)
                mean1 = mean(cumu(1:i));
                mean2 = mean(cumu(i+1:ncu));
                var1 = cov(cumu(1:i));
                var2 = cov(cumu(i+1:ncu));
                as(i) = (mean1 - mean2)/(sqrt(var1/i+var2/(tdiff-i)));
                titletext=['AS(t) Function; wl = ', num2str(ZG.compare_window_yrs)];
            end
        case 'lta'
            for i = 1:length(cumu)-winlen_days
                cu = [cumu(1:i-1) cumu(i+winlen_days+1:ncu)];
                mean1 = mean(cu);
                mean2 = mean(cumu(i:i+winlen_days));
                var1 = cov(cu);
                var2 = cov(cumu(i:i+winlen_days));
                as(i) = (mean1 - mean2)/(sqrt(var1/(ncu-winlen_days)+var2/winlen_days));
                titletext=['LTA(t) Function; wl = ', num2str(ZG.compare_window_yrs)];
                probabilityButtonCallback=@(~,~)translating('z');
            end
        case 'bet'
            Catalog=ZG.newcat;
            NumberBins = length(xt);
            BetaValues = zeros(1,NumberBins)*NaN;
            TimeBegin = min(Catalog.Date);
            NumberEQs = Catalog.Count;
            TimeEnd = max(Catalog.Date);
            
            if (ZG.compare_window_yrs >= TimeEnd-TimeBegin) || (ZG.compare_window_yrs <= 0)
                errordlg('winlen_days is either too long or too short.');
                return;
            end
            
            for i = 1:length(cumu)-winlen_days
                EQIntervalReal=sum(cumu(i:i+(winlen_days-1)));
                NormalizedIntervalLength=winlen_days/NumberBins;
                STDTheor=sqrt(NormalizedIntervalLength*NumberEQs*(1-NormalizedIntervalLength));
                BetaValues(i) = (EQIntervalReal-(NumberEQs*NormalizedIntervalLength))/STDTheor;
            end
            as = BetaValues;
            titletext=['LTA(t) Function; \beta-values; wl = ', num2str(ZG.compare_window_yrs)];
            probabilityButtonCallback=@(~,~)translating('beta');
    end
    
    %  Plot the as(t)
    cum=findobj('Type','Figure','-and','Name','Cumulative Number Statistic');
    
    % Set up the Cumulative Number window
    if isempty(cum)
        cum=figure('Name','Cumulative Number Statistic');  %TODO this case wasn't handled. created a simple figure
    else
        figure(cum);
    end
    delete(findobj(cum,'Type','axes'));
    tet1 = '';
    try delete(sinewsta); catch ME; error_handler(ME, ' '); end
    try delete(te2); catch ME; error_handler(ME, ' '); end
    try delete(ax1); catch ME; error_handler(ME, ' '); end
    %clf
    hold on
    set(gca,'visible','off','FontSize',ZmapGlobal.Data.fontsz.m,...
        'LineWidth',1.5,...
        'Box','on')
    
    % orient tall
    set(gcf,'PaperPosition',[2 1 5.5 7.5])
    rect = [0.2,  0.15, 0.65, 0.75];
    axes('position',rect)
    [pyy,ax1,ax2] = plotyy(xt,cumu2,xt,as);
    
    set(pyy(2),'YLim',[min(as)-2  max(as)+5],'XLim',[t0b teb],...
        'XTicklabel',[],'TickDir','out')
    xl = get(pyy(2),'XLim');
    set(pyy(1),'XLim',xl);
    
    set(ax1,'LineWidth',2.0,'Color','b')
    set(ax2,'LineWidth',1.0,'Color','r')
    xlabel('Time in years ','FontWeight','normal','FontSize',ZmapGlobal.Data.fontsz.m)
    ylabel('Cumulative Number ','FontWeight','normal','FontSize',ZmapGlobal.Data.fontsz.m)
    
    if ~isempty(probabilityButtonCallback)
        uicontrol('Style','Pushbutton','Units','normal',...
            'Position',[.35 .0 .3 .05],'String','Translate into probabilities',...
            'callback',probabilityButtonCallback);
    end
    
    title(titletext,'FontWeight','bold','FontSize',ZmapGlobal.Data.fontsz.m,'Color','k');
    
    i = find(as == max(as));
    if length(i) > 1
        i = i(1);
    end
    
    tet1 =sprintf('Zmax: %3.1f at %s ',max(as),char(xt(i),'uuuu-MM-dd hh:mm:ss'));
    
    vx = xlim;
    vy = ylim;
    xlim([vx(1), dateshift(teb,'end','Year') ]);
    ylim([vy(1),  vy(2)+0.05*vy(2)]);
    te2 = text(vx(1)+0.5, vy(2)*0.9,tet1);
    set(te2,'FontSize',ZmapGlobal.Data.fontsz.m,'Color','k','FontWeight','normal')
    
    grid
    set(gca,'Color',ZG.color_bg)
    
    hold on;
    
    
    % plot big events on curve
    %
    if ~isempty(big)
        l = ZG.newt2.Magnitude > ZG.big_eq_minmag;
        f = find( l  == 1);
        bigplo = plot(big.Date,f,'hm');
        set(bigplo,'LineWidth',1.0,'MarkerSize',10,...
            'MarkerFaceColor','y','MarkerEdgeColor','k')
        stri4 = [];
        for i = 1:big.Count
            s = sprintf('  M=%3.1f',big.Magnitude(i));
            stri4 = [stri4 ; s];
        end
    end
    
    
    % repeat button
    
    uicontrol('Units','normal',...
        'Position',[.25 .0 .08 .05],'String','New',...
        'callback',@callbackfun_003)
    
    if exist('stri', 'var')
        vx=xlim;
        vy=ylim;
        %v = axis;
        
        tea = text(vx(1)+0.5,vy(2)*0.9,stri) ;
        set(tea,'FontSize',ZmapGlobal.Data.fontsz.m,'Color','k','FontWeight','normal')
    end
    
    strib = [ZG.newcat.Name];
    
    set(cum,'Visible','on');
    figure(cum);
    watchoff
    watchoff(cum)
    done
    
    xl = get(pyy(2),'XLim');
    set(pyy(1),'XLim',xl);
    
    
    %%
    
    function [winLengthYears, binDays] = choose_parameters(winLengthYears, binDays) % window length, bin length
        def = {num2str(winLengthYears), num2str(days(binDays))};
        tit ='beta computation input parameters';
        prompt={ 'Compare window length (years)',...
            'bin length (days)'};
        ni2 = inputdlg(prompt,tit,1,def);
        
        winLengthYears = str2double(ni2{1});
        binDays = days(str2double(ni2{2}));
    end
    
    %% callback functions
    function callbackfun_003(mysrc,myevt)
        
        callback_tracker(mysrc,myevt,mfilename('fullpath'));
        newsta(sta); % cannot e put directly into uicontrol's callback because 'sta' would be unchanging
    end
    
    function translating(value2trans) % autogenerated function wrapper
        % translating
        % turned into function by Celso G Reyes 2017
        
        ZG=ZmapGlobal.Data; % used by get_zmap_globals
        
        report_this_filefun(mfilename('fullpath'));
        if isempty(ZG.newcat)
            ZG.newcat=a;
        end
        
        % call
        ButtonName = questdlg('Translate which data into probabilities?', ...
            'Reference Data', ...
            'uniform rate', 'real data', 'uniform rate');
        switch ButtonName
            case 'uniform rate'
                way='unif';
            case 'real data'
                way='real';
            otherwise
                return
        end % switch
        
        % call
        helpdlg(['The translation is done by randomly calculating beta values for a given setup.',...
            'The more often the process is repeated, the more reliable the results get, but the ',...
            'longer the simulation lasts.'],'About translation');
        myans=inputdlg('Number of repetitions: ( > 20 )', 'Translation',1,{num2str(1000)});
        if isempty(myans)
            return
        end
        NuRep=str2double(myans{1});
        
        BinLength=1/length(xt); %TOFIX where does xt come from/go
        NuBins=length(xt);
        
        % produce Big Catalog
        if way=='unif'
            BigCatalog=sort(rand(100000,1));
        else % if way=='real'
            whichs=ceil(length(ZG.newcat)*rand(100000,1)); % numbers in whichs from 1 to length(ZG.newcat)
            BigCatalog(100000,1)=0;
            for i=1:100000
                BigCatalog(i,1)=ZG.newcat(whichs(i),3);    % ith element of BigCatalog is random out of ZG.newcat
            end
            BigCatalog=sort(BigCatalog);
            BigCatalog=(BigCatalog-min(BigCatalog))/(max(BigCatalog)-min(BigCatalog));
        end
        
        % call
        sim_2prob(value2trans);
        
        switch value2trans
            case 'zval'
                ProbValuesZ=[];
                for i=1:length(as)
                    ProbValuesZ(1,i)=normcdf(as(1,i), IsFitted(2,1), IsFitted(2,2));
                end
                
            case 'beta'
                ProbValuesBeta=[];
                for i=1:length(BetaValues)
                    ProbValuesBeta(1,i)=normcdf(BetaValues(1,i), IsFitted(1,1), IsFitted(1,2));
                end
            otherwise
                error('unknown value to translate')
        end
        
    end
    
    function sim_2prob(value2trans) % autogenerated function wrapper
        % turned into function by Celso G Reyes 2017
        
        ZG=ZmapGlobal.Data; % used by get_zmap_globals
        
        
        report_this_filefun(mfilename('fullpath'));
        
        
        % needed variables
        % BigCatalog        big catalog from which to take the eqs randomly, produced by translating
        %                   consists of 100000 eqs
        % sampSize          number of earthquakes in a bin, i.e. sample size (was ni)
        % NuBins            number of bins
        % BinLength         1/length(xt), length of shortest possible interval
        % winlen_days               length of interval in times shortest
        % NuRep             number of repetitions
        
        delta=winlen_days/NuBins;
        
        for nto=1:NuRep
            disp(nto);
            
            which=ceil(100000*(rand(sampSize)));
            for i=1:sampSize
                rancata(i)=BigCatalog(which(i));
            end
            clear i which;
            rancata=ceil(rancata*NuBins);
            
            for i=1:NuBins
                l=sum(rancata==i); Bins(i,1)=sum(l); clear l;
            end
            clear rancata i;
            
            FirstBin=ceil(rand(1)*(NuBins-winlen_days+1));
            
            
            zin=Bins(FirstBin:FirstBin+winlen_days-1); zout=[Bins(1:FirstBin-1,1); Bins(FirstBin+winlen_days:NuBins,1)];
            ToBeFitted(nto,1)=nto;
            % calculating beta
            ToBeFitted(nto,2)=(sum(zin)-sampSize*delta)/(sqrt(sampSize*delta*(1-delta)));
            % calculating z
            ToBeFitted(nto,3)=(mean(zout)-mean(zin))/(sqrt(var(zin)/sum(zin)+var(zout)/sum(zout)));
            clear Bins FirstBin zin zout;
        end
        clear BigCatalog nto delta;
        
        [meanval, std] =normfit(ToBeFitted(:,2)); IsFitted(1,1)=meanval; IsFitted(1,2)=std;
        [meanval, std] =normfit(ToBeFitted(:,3)); IsFitted(2,1)=meanval; IsFitted(2,2)=std;
        clear meanval std;
        clear ToBeFitted;
        
        switch value2trans
            case 'beta'
                Pbeta = normcdf(BetaValues,IsFitted(1,1),IsFitted(1,2));
                l = Pbeta == 0; Pbeta(l) = nan;
            case 'z'
                Pbeta = normcdf(BetaValues,IsFitted(2,1),IsFitted(2,2));
                l = Pbeta == 0; Pbeta(l) = nan;
        end
        
        % plot the resuts
        figure
        pq = -log10(1-Pbeta); l = isinf(pq);pq(l) = 18 ;
        pl1 = plot(xt,pq,'color',[0.0 0.5 0.9]);
        hold on
        l = pq < 1.3; pq(l) = nan;
        pl3 = plot(xt,pq,'b','Linewidth',2);
        
        pq = -log10(Pbeta);l = isinf(pq);pq(l) = 18 ;
        pl2 = plot(xt,pq,'color',[0.8 0.6 0.8]);
        l = pq < 1.3; pq(l) = nan;
        pl4 = plot(xt,pq,'r','Linewidth',2);
        
        maxd = [get(pl1,'Ydata') get(pl2,'ydata') ]; maxd(isinf(maxd)) = []; maxd = max(maxd);
        if maxd < 5 ; maxd = 5; end
        if isnan(maxd) == 1 ; maxd = 10; end
        
        legend([pl3 pl4],'Rate increases','Rate decreases');
        set(gca,'Ylim',[0 maxd+1])
        set(gca,'YTick',[1.3 2 3 4 5])
        set(gca,'YTickLabel',[ '    5%' ; '    1%' ;  '  0.1%' ;  ' 0.01%' ; '0.001%'])
        set(gca,'TickDir','out','Ticklength',[0.02 0.02],'pos',[0.2 0.2 0.7 0.7]);
        xlabel('Time [years]')
        ylabel('Significance level');
        set(gcf,'color','w')
        grid
        
        uicontrol('Units','normal',...
            'Position',[.8 .0 .1 .05],'String','Explain ... ',...
            'callback',@(~,~)showweb('explproba'));
        
        delete(probut)
        
        
    end
    
end